哪些内存需要回收？

    程序计数器、虚拟机栈、本地方法栈是每个线程私有的内存空间，随线程而生，随线程而亡，无需考虑回收问题。
    JVM中的方法区和堆需要进行内存回收
判断对象是否死亡

    1、引用计数算法 （废弃）
    对象被引用就+1，难以解决循环引用问题

    2、可达性算法（栈、方法区的引用对象）
    1）概念：通过一系列称为 “GC roots” 的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC roots没有任何引用链相连时，证明此对象不可用。

    2）GC roots的对象包括：

        1、虚拟机栈中引用的对象
        2、本地方法栈 native引用的对象
        3、方法区中 类静态属性 引用的对象
        4、方法区中常量引用的对象

    3）引用的分类：
    强引用(new)，软引用(soft)，弱引用(weak)，虚引用(Phantom)

    4）当一个对象不可达GC Roots时，这个对象并不会立马被回收，被真正的回收需要经历两次标记：
        如果没有GC roots相连接的引用链，他将第一次标记并进行筛选，看是否有必要执行finalize方法；
        如果有必要执行finalize方法，对象将被放置在F-Queue队列中，虚拟机会触发一个Finalize()线程去执行，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize中拯救自己，只要重新引用链上的任何一个对象建立关联。

2）java垃圾回收时间

    自动：不需要显示释放对象内存，虚拟机自行执行；
    GC时间：在虚拟机空闲、堆内存不足时触发，低优先级垃圾回收线程；
    GC对象：没任何引用的对象（可达性算法）

HotSpot虚拟机的垃圾回收器
年轻代：serial收集器（单线程，在进行垃圾回收时，必须暂停其他所有的工作线程，直至他收集完成） parNew（serial收集器的多线程版本，只有它和serial能配合CMS收集器工作） parallel scavenge G1
老年代：parallel old serial oid CMS
cms
初始标记 	gc-roots能直接关联的对象 stop the world
并发标记 	进行gc tracing的过程
重新标记 	修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录 stop the world
并发清除 	基于标定结果，直接清除对象


垃圾回收算法

1）标记-清除算法 直接回收不存活的（老年代）

    分为标记和清除两个过程，首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象
    缺点：效率问题：标记和清除两个过程的效率都不高；
    空间问题：标记清除后会产生大量不连续的内存碎片

2）复制算法 （新生代）

    把Eden:From Survivor:To Survivor空间大小设成8:1:1，对象总是在Eden区出生，若Eden区满，触发minor GC，若GC后，存活的对象太多，to survivor内存不够时，通过分配担保机制复制到老年代

3）标记 - 整理算法（老年代）

    和标记-清除算法类似，在清除对象的时候先将可回收对象移动到一端，然后清除掉端边界以外的对象
    优点：1、解决大量内存碎片问题；2、当对象存活率较高时，效率也很好

4）分代收集算法	根据对象存活周期的不同，将内存空间划分为几块

    1、新生代(复制算法)
    2、老年代（标记-清除算法，标记-整理算法）
yGC触发条件：

1、新对象生成，且eden空间申请失败，会触发yGC
2、full gc时会伴随yGC

FullGC触发条件：对整个堆进行整理
1、老年代被写满（尽量避免创建大的对象以及数组）

    1、通过-XMN虚拟机参数调大新生代的大小
    2、通过-xx：maxTenuringThredhold调大对象那个进入老年代的年龄

2、system.gc()被显示调用，但是虚拟机不一定真正去执行
3、空间分配担保失败**

    1、用复制算法的Minor GC需要老年代的内存空间作担保
    2、MinorGC触发前，比较老年代的剩余空间和新生代所有对象大小，老年代小，且不允许冒险，则fullgc
    3、允许冒险，继续比较对象历次与本次进入老年代的平均大小，若本次大，则FullGC

为什么要担保：	每次minorgc，新生代年龄满15的会进入老年代，如果新生代全部对象都一起满15会导致老年代不够放

4、永久代空间不足（JDK 1.7及以前）

    在JDK1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些Class的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么虚拟机会抛出java.lang.OutOfMemoryError。jdk8之后，由Meta space代替了perm永久代，用于防止永久代溢出，使用了自扩容机制。

5、Concurrent Mode Failure

    执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时性的空间不足），便会报Concurrent Mode Failure错误，并触发Full GC

内存分配与回收策略	对象的内存分配

    1、大多数情况下，对象在新生代eden区分配，eden区没有足够的空间进行分配时，虚拟机将发起一次minor gc
    2、大对象（需要大量连续内存空间的java对象,超出eden区大小）直接进入老年代
    3、长期存活的对象将进入老年代：（存活轮次多：15）
        jvm采用分代收集的思想管理内存，给每个对象定义了一个年龄计数器。如果对象在eden出生后并经过第一次minor GC后仍然存活，将移动到survivor中，age++，对象在survivor区每经过一次minorGC，age++，age=15时，升到老年代。

    4、动态对象年龄判断（防止survivor满）
        如果在survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到maxTenutingThreshold中要求的年龄。

    5、空间分配担保机制
        在y gc之前，jvm会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，大于表示安全；如果小于：检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。

新生代的GC（Minor GC）：

新生代通常存活时间较短基于Copying算法进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到老年代。

在执行机制上JVM提供了串行GC(SerialGC)、并行回收GC(ParallelScavenge)和并行GC(ParNew)：

串行GC
在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。

并行回收GC
在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。

并行GC

与老年代的并发GC配合使用。

 

老年代的GC（Major GC/Full GC）：

老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗。

在执行机制上JVM提供了串行GC(Serial MSC)、并行GC(Parallel MSC)和并发GC(CMS)。

串行GC（Serial MSC）
client模式下的默认GC方式，可通过-XX:+UseSerialGC强制指定。每次进行全部回收，进行Compact，非常耗费时间。

并行GC（Parallel MSC）(吞吐量大，但是GC的时候响应很慢)
server模式下的默认GC方式，也可用-XX:+UseParallelGC=强制指定。可以在选项后加等号来制定并行的线程数。

并发GC（CMS）(响应比并行gc快很多，但是牺牲了一定的吞吐量)

使用CMS是为了减少GC执行时的停顿时间，垃圾回收线程和应用线程同时执行，可以使用-XX:+UseConcMarkSweepGC=指定使用，后边接等号指定并发线程数。CMS每次回收只停顿很短的时间，分别在开始的时候（Initial Marking），和中间（Final Marking）的时候，第二次时间略长。CMS一个比较大的问题是碎片和浮动垃圾问题（Floating Gabage）。碎片是由于CMS默认不对内存进行Compact所致，可以通过-XX:+UseCMSCompactAtFullCollection。

-------------------------------------------cms------------------------------------------
cms垃圾回收机制：（并发，标记清除算法垃圾回收器）
虚拟机参数-"XX:+UseConcMarkSweepGC"
使用场景：

GC过程短暂停，适合对时延要求较高的服务，用户线程不允许长时间的停顿。
缺点：

服务长时间运行，造成严重的内存碎片化。算法实现比较复杂
实现机制

根据GC的触发机制分为：周期性Old GC（被动）和主动Old GC
周期性Old GC，执行的逻辑也叫Background Collect，对老年代进行回收，在GC日志中比较常见，由后台线程ConcurrentMarkSweepThread循环判断（默认2s）是否需要触发。
触发条件

1、如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，虚拟机会根据收集的数据决定是否触发（建议线上环境带上这个参数，不然会加大问题排查的难度）。
2、老年代使用率达到阈值 CMSInitiatingOccupancyFraction，默认92%。
3、永久代的使用率达到阈值 CMSInitiatingPermOccupancyFraction，默认92%，前提是开启 CMSClassUnloadingEnabled。
4、新生代的晋升担保失败。

晋升担保失败

老年代是否有足够的空间来容纳全部的新生代对象或历史平均晋升到老年代的对象，如果不够的话，就提早进行一次老年代的回收，防止下次进行YGC的时候发生晋升失败。
周期性Old GC过程

等待闲置-->初始化标记-->并发标记-->预处理-->重新标记-->并发清理-->调整堆大小-->重置-->等待闲置

1、InitialMarking（初始化标记，整个过程STW）
该阶段单线程执行，主要分分为两步：

    标记GC Roots可达的老年代对象；
    遍历新生代对象，标记可达的老年代对象；
2、Marking（并发标记）

该阶段GC线程和应用线程并发执行，遍历InitialMarking阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。

因为该阶段并发执行的，在运行期间可能发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。

为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代。
3、Precleaning（预清理）

通过参数CMSPrecleaningEnabled选择关闭该阶段，默认启用，主要做两件事情：

    处理新生代已经发现的引用，比如在并发阶段，在Eden区中分配了一个A对象，A对象引用了一个老年代对象B（这个B之前没有被标记），在这个阶段就会标记对象B为活跃对象。
    在并发标记阶段，如果老年代中有对象内部引用发生变化，会把所在的Card标记为Dirty（其实这里并非使用CardTable，而是一个类似的数据结构，叫ModUnionTalble），通过扫描这些Table，重新标记那些在并发标记阶段引用被更新的对象（晋升到老年代的对象、原本就在老年代的对象）

4、AbortablePreclean（可中断的预清理）

该阶段发生的前提是，新生代Eden区的内存使用量大于参数CMSScheduleRemarkEdenSizeThreshold 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。


5、FinalMarking（并发重新标记，STW过程）

6 并发清理。用户线程被重新激活，同时清理那些无效的对象。
7 重置。 CMS清除内部状态，为下次回收做准备。 


该阶段发生的前提是，新生代Eden区的内存使用量大于参数CMSScheduleRemarkEdenSizeThreshold 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。


